import numpy as np


class ConvNet(object):

    def __init__(self, x_initial, y_initial):
        self.x_size = x_initial.shape
        self.y_size = y_initial.shape
        self.num_pools = none
        self.num_convolutions = none
        self.num_feed_forward = none

        for i in range(self.num_pools):
            # create pooling weights
            pass

        for i in range(self.num_convolutions):
            # create convolutional weights
            pass

        for i in range(self.num_feed_forward):
            # create fully conncected weights
            # fully connected layer at the end of the network
            pass

    def optimize(self, iterations):
        # implement minibatches
        for i in range(iterations):
            # predict and output
            pass
            # backward propagate
            pass

    # Convolution Functions

    def pad(self, array, amount):
        # amount padds that amount in each direction
        # be careful with 3d vectors!!!!
        array = np.pad(array, [(amount, amount), (amount, amount)], mode="constant")
        return array

    # single convolutional operation
    def convolve_window(self, x_window, w, b):
        return np.sum(np.multiply(x_window, w)) + b

    def convolutional_forward(self, x, w, b, step):
        output_height = w.shape[0]
        output_width = w.shape[1]
        output_length = w.shape[2]
        # apply convolution formula for the number of windows generated by convolution operation
        num_x_windows = (x.shape[1] - output_width)/step + 1
        num_y_windows = (x.shape[0] - output_height)/step + 1
        num_z_windows = output_length

        # check to see if paramaters result in a vailid convolution
        if type(num_x_windows) != int or type(num_y_windows) != int:
            raise ValueError:
                print("Error: step size is not valid or insufficient padding")

        # loop through each window and apply convolution to it
        for i in range(num_x_windows):
            # create x window coordinates
            x_start = i*output_width+step*i
            x_end = (i+1)*output-width+step*i
            for j in range(num_y_windows):
                # create y window coordinates
                y_start =
                y_end =
                for k in range(num_z_windows):
                    # calculate a window element
                    # and add it to the output vector
                    x_window =


        # loop through convolution windows and apply num_convolutions
        # store convolutions in the next z and then apply activations function to them
        # dont forget to apply normalization and center data around the origin



    def convolutional_backward(self):
        # not really sure how this works yet, but will derive from DL textbook
        pass

    # Pool Funtions

    def pool_forward(self):
        pass

    def pool_backward(self):
        pass

    def creat_mask(self):
        pass

    def distribute_value(self):
        pass
